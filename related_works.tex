\section{Related Work}

The traditional approach for clustering sequences was to use a hierarchical clustering method.


The traditional approach for clustering 16S rRNA sequences has involved the use of a multiple sequence alignment (MSA) for all sequences.

Optimal multiple sequence alignment between a collection of sequences can be done with a dynamic programming algorithm.

Impractical for the large number of sequences.
454 technologies can produce millions of sequences.

Greedy methods can be used to iteratively build a rooted tree.
Then a specific cutoff can be given to split the tree into clusters.

Alternatives include building a distance matrix between each pair of sequences.  
Once the distance matrix is built, clustering is typically done via hierarchical methods.
Agglomerative methods involve a bottom-up approach, where each sequence starts as its own cluster then iteratively merged with other clusters.
Divisive methods, on the other hand, work from a top-down approach, where all sequences belong to a single cluster then are iteratively split into smaller clusters.

While hierarchical methods requires less work than the multiple sequence alignment, calculating the pairwise distances generally requires cubic work, making it impracticable for a large number of sequences.

An alternative approach for clustering sequences involves selecting a sequence to become the cluster center.
The center is then used to recruit the remaining sequences that fall within some given \emph{distance} threshold to the center.
The distance between two sequences can include edit distance (also called Levenshtein distance), k-mer distance, similarity, identity, ...

% Booktabs require to add \usepackage{booktabs} to your document preamble
\begin{table}[t]
\centering\scriptsize
\hspace*{-1.5cm}
\begin{tabular}{@{}llcccccccc@{}}
\toprule
Tool        & Description                                                                                                                                       & DNA & Protein & \emph{De novo} & Ref & Exact & Multi-core & Distance measure         & Strategy     \\ \midrule
BLAST\cite{altschul_gapped_1997}       & \multirow{4}[3]{4.5cm}{Alignment tool using neighborhood keywords to speed up alignment A script can be used to align to a reference database and filter results.}       & Y   & Y       & N       & Y             & N     & Y                & N/A                      & N/A          \\
\\
\\
\\
\\
\\
AbundantOTU\cite{ye_identification_2010} &  \multirow{2}[3]{4.5cm}{Fast method to build cluster centers from abundant k-mers}                                                                                         & Y   & N       & Y       & N             & Y     & N                & Sim               & Greedy       \\
\\
\\
\\
CD-HIT\cite{li_clustering_2001,fu_cd-hit:_2012}      &  \multirow{2}[3]{4.5cm}{Family of clustering tools. Speed comes from using a short word filter to prune potential alignments.}                                             & Y   & Y       & Y       & N             & N\tablefootnote{Only exact for a preset number of similarities.}    & Y                & Sim               & Greedy       \\
\\
\\
\\
DNACLUST\cite{ghodsi_dnaclust:_2011}    &  \multirow{2}[3]{4.5cm}{Fast, exact clustering tool that exploits database sequence similarity to reduce work.}                                                            & Y   & N       & Y       & Y             & Y     & Y                & Sim / Mis & Greedy       \\
\\
\\
\\
DySC\cite{zheng_dysc:_2012}        &  \multirow{2}[3]{4.5cm}{Uses a two-step clustering heuristic to build larger clusters.}                                                                                    & Y   & N       & Y       & N             & N     & N                & Sim               & Greedy       \\
\\
\\
ESPRIT-Tree\cite{cai_esprit-tree:_2011} &  \multirow{2}[3]{4.5cm}{Hierarchical method that represents a cluster of sequences as a single probabilistic sequence and uses that for pair-wise alignments of clusters.} & Y   & N       & Y       & N             & N\tablefootnote{Default k-mer length filter does not guarantee correctness.}     & N                & Sim               & Hierarchical \\
\\
\\
\\
\\
HPC-CLUST\cite{rodrigues_hpc-clust:_2014}   &  \multirow{2}[3]{4.5cm}{Scalable, and flexible hierarchical method for clustering pre-aligned reads.}                                                                      & Y   & N       & Y       & N             & N/A\tablefootnote{Takes as input pair-wise sequence distances.}    & Y                & Sim               & Hierarchical \\
\\
\\
\\
SEED\cite{bao_seed:_2011}        &  \multirow{2}[3]{4.5cm}{Very fast clustering of highly similar reads within 3 mismatches.}                                                                                 & Y   & N       & Y       & N             & Y     & N                & Mis               & Greedy       \\
\\
\\
UCLUST\cite{edgar_search_2010}      &  \multirow{2}[3]{4.5cm}{Fast clustering method that only compares a sequence to a predetermined number of potential centers.}                                              & Y   & Y       & Y       & Y             & N\tablefootnote{Default is inexact, but also offers an exact alignment mode.}    & Y                & Sim               & Greedy       \\ 
\\
\\
\\
\bottomrule
\end{tabular}
\caption{Clustering tools used in metagenomic studies. DNA and Protein refers to whether the clustering tool can work with DNA and protein sequences, respectively.  \emph{De novo} and Ref refers to whether the clustering tool can cluster sequences without and with a reference database, respectively. Exact clustering tools are those that compare a sequence to every cluster center. Multi-core clustering tools are those that support multiple threads.  Distance measure refers to tools that define distance between two sequences as percent similarity or mismatch number.  Strategy defines how the centers are created with greedy methods having some fixed procedure of selecting the center from the dataset, while hierarchical refers to those that are constructed using a guide tree.}
\hspace*{-1.5cm}
\end{table}



\subsection{Greedy clustering paradigm}

A commonly-used clustering paradigm for sequence clustering is to iteratively select a sequence to serve as a cluster center and then recruit all remaining sequences that fall within some given distance of the cluster center.
This process is repeated until no more sequences remain or the predetermined list of centers is exhausted.

\subsection{Cluster center selection}
There are three strategies used for selecting potential cluster centers.
In {\bf \emph{de novo}} clustering, centers are selected \emph{only} from the set of input sequences.  Strategies for selecting potential centers are described below.
In {\bf closed-reference} clustering, a list of predetermined centers is given, such as a collection of previously discovered OTUs\cite{desantis_greengenes_2006,quast_silva_2013}.
In {\bf open-reference} clustering, sequences are first recruited to a list of predetermined cluster centers.
Afterwards, the centers are chosen by the \emph{de novo} methods.

Selecting which sequence to use as the cluster center is a difficult problem.
One strategy is to select the remaining sequence with the longest length.
An intuitive argument is that a longer sequence would more likely recruit shorter sequences.
However, the more rigorous argument is that selecting the longest remaining sequence allows you certain mathematical guarantees when aligning and recruiting shorter sequences.
For example, given 3 sequences: \emph{A}, \emph{B}, and \emph{C}.  If the length of \emph{A} is less than \emph{B} and \emph{C} and we know the distance between \emph{A} and \emph{B} and \emph{A} \emph{C}, we can not say anything for certain about the distance between \emph{A} and \emph{C}.
We do not have any data about the overlapping regions between \emph{B} and \emph{C}.

{\bf INSERT FIGURE OF THIS.}

This center selection strategy is used by CD-HIT\cite{li_clustering_2001}, DNACLUST\cite{ghodsi_dnaclust:_2011}.

Frequency of k-mers.

\subsection{Sequence recruitment}

A key part of any clustering algorithm is how the distance between two objects is computed.
In the case of sequence clustering, we need to calculate the distance between two strings.
Commonly-used distance metrics include:

\begin{itemize}

  \item Edit (Levenshtein) distance
  \item K-mer
  \item Identity

\end{itemize}

\subsubsection{Edit distance}

The \emph{edit distance} between a text string $t = t_1 t_2 ... t_n$ and pattern string $p = p_1 p_2  ... p_m$ is the minimum number of differences between them such that one string can be transformed into the other.
A difference is one of the following:

\begin{enumerate}

  \item A character of the text corresponds to a different character of the pattern.
  \item A character of the text corresponds to no character (a gap) in the pattern.
  \item A character of the pattern corresponds to no character (a gap) in the text.

\end{enumerate}

Algorithms for $k-mismatches$ only satisfies differences of type 1.

We use the Needlemanâ€“Wunsch{\bf NEED CITATION} dynamic programming algorithm to calculate the edit distance between two strings.


 Algorithm to solve $k$-differences 

\begin{equation}
\begin{aligned}
M[i, j] = \quad min
\begin{cases}
\quad M[i - 1, j] + 1 \\
\quad M[i, j-1] + 1 \\
\quad M[i-1, j-1] + \begin{cases} 
0, \quad \text{if }t_i == p_j \\
1, \quad \text{else } \\
\end{cases}
\end{cases}
\end{aligned}
\end{equation}



% Edit distance computation
 \begin{algorithm}
 \caption{Compute Edit Distance between two strings.  $O(nm)$ work.}\label{edit_distance}
 \begin{algorithmic}[1]
 \Procedure{ComputeEditDistance}{$a,b$}
 \State $n\gets |a|$
 \State $m\gets |b|$

 \For{$i=0 .. n$}   \State $M(i,0) \gets i$ \EndFor
 \For{$i=0 .. m$}
  \State $M(0,i) \gets i$
\EndFor

 \For{$i=1 .. n$}
 \For{$j=1 .. m$}
  \State $row \gets M(i-1,j) + 1$ \Comment Number of edits with a gap inserted into $b$
  \State $col \gets M(i,j-1) + 1$ \Comment Number of edits with gap inserted into $a$
  \State $diag \gets M(i-1, j-1)$ \Comment Number of edits with matching characters $a_i$ and $b_j$
  \If{$a_i \neq b_j$}  $diag \gets diag +  1$ \EndIf
  \State $M(i,j) \gets \text{min}(row,col,diag)$
\EndFor
\EndFor
\Return $M(n,m)$
\EndProcedure
\end{algorithmic}
\end{algorithm}

If we want to find a global alignment within $k$-differences, we only need to worry about a $2k+1$ band along the diagonal.
This reduces the amount of work from $O(n^2)$ to $O(nk)$.
However, this assumes we are aligning the two sequences end-to-end.

